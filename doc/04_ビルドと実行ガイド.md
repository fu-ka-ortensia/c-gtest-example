# ビルドと実行ガイド

## ビルドシステムの概要

本プロジェクトは CMake を使用したビルドシステムを採用しています。

### ビルドの流れ

```
source/
├── target/        (ソースコード: C)
├── tests/         (テストコード: C++)
├── fff/           (FFF フレームワーク)
├── GoogleTest/    (Google Test フレームワーク)
└── CMakeLists.txt (ビルド設定)
  ↓
cmake (Configure)
  ↓
build/
├── CMakeFiles/    (キャッシュ)
├── CMakeCache.txt
├── Makefile       ← CMake が生成
  ↓
make (Build)
  ↓
build/tests/
├── moduleA/
│   └── test_moduleA
├── moduleB/
│   └── test_moduleB
└── moduleC/
    └── test_moduleC
  ↓
ctest (Test Execution)
```

## ビルドのコンパイルオプション

### Debug ビルド（デフォルト）

```cmake
# CMakeLists.txt の設定
set(CMAKE_C_FLAGS_DEBUG "-O0 -g --coverage -fprofile-arcs -ftest-coverage")
set(CMAKE_CXX_FLAGS_DEBUG "-O0 -g --coverage -fprofile-arcs -ftest-coverage")
```

**オプション説明**:

| オプション | 説明 |
|-----------|------|
| `-O0` | 最適化なし（デバッグに最適） |
| `-g` | デバッグシンボル情報を含める |
| `--coverage` | カバレッジ計測用フラグ |
| `-fprofile-arcs` | 関数呼び出しのアークを記録 |
| `-ftest-coverage` | テストカバレッジ情報を生成 |

### Release ビルド

```cmake
set(CMAKE_C_FLAGS_RELEASE "-O3 -DNDEBUG")
set(CMAKE_CXX_FLAGS_RELEASE "-O3 -DNDEBUG")
```

**オプション説明**:

| オプション | 説明 |
|-----------|------|
| `-O3` | 最高レベルの最適化 |
| `-DNDEBUG` | assert() マクロを無効化 |

## ビルド手順

### 前提条件の確認

Ubuntu 環境で必要なツールをインストール：

```bash
sudo apt-get update
sudo apt-get install -y \
    build-essential \
    cmake \
    git \
    gcov \
    lcov \
    python3-pip

pip3 install gcovr
```

### 1. ビルドディレクトリの作成と移動

```bash
mkdir -p build
cd build
```

### 2. CMake の設定（Configure ステップ）

**Debug ビルド（デフォルト）**:

```bash
cmake -DCMAKE_BUILD_TYPE=Debug ..
```

**Release ビルド**:

```bash
cmake -DCMAKE_BUILD_TYPE=Release ..
```

**詳細な出力**:

```bash
cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_VERBOSE_MAKEFILE=ON ..
```

### 3. ビルドの実行

```bash
make
```

**出力例**:

```
Scanning dependencies of target test_moduleC
[ 10%] Building CXX object tests/moduleC/CMakeFiles/test_moduleC.dir/test_moduleC.cpp.o
[ 20%] Linking CXX executable tests/moduleC/test_moduleC
[ 20%] Built target test_moduleC
[100%] Built target test_moduleA test_moduleB test_moduleC
```

### 4. ビルドのクリーン

```bash
# build/ ディレクトリ内の生成ファイルをクリア
make clean

# または全部削除してやり直し
cd ..
rm -rf build/
mkdir build && cd build
cmake ..
make
```

## テストの実行

### 1. 全テストの実行

```bash
cd build
ctest
```

**出力例**:

```
Test project /home/fu-ka/c_test_prj/build
      Start  1: ModuleATest
 1/3 Test #1: ModuleATest .................   Passed    0.01 sec
      Start  2: ModuleBTest
 2/3 Test #2: ModuleBTest .................   Passed    0.01 sec
      Start  3: ModuleCTest
 3/3 Test #3: ModuleCTest .................   Passed    0.02 sec

100% tests passed, 0 tests failed out of 3
```

### 2. 特定のモジュールのテストのみ実行

```bash
# moduleC のみ
ctest -R "ModuleC" --output-on-failure

# 正規表現での指定
ctest -R "Module[AB]" --output-on-failure
```

### 3. 失敗時の詳細出力

```bash
# 失敗した場合は詳細を表示
ctest --output-on-failure

# より詳細な情報
ctest --output-on-failure -V

# テスト実行時のメモリ情報も含める
ctest --output-on-failure -D ExperimentalMemCheck
```

### 4. テスト結果を XML で出力

```bash
ctest -T Test --output-xml test-results.xml
```

生成されたファイル: `Testing/Temporary/test-results.xml`

### 5. 個別テスト実行ファイルの直接実行

```bash
# moduleC のテスト実行ファイルを直接実行
./tests/moduleC/test_moduleC

# より詳細な出力（Google Test オプション）
./tests/moduleC/test_moduleC --gtest_detail=all

# 特定のテストケースのみ実行
./tests/moduleC/test_moduleC --gtest_filter=ModuleCTest.WriteDataSuccess
```

## カバレッジレポート

### 1. 基本的なカバレッジ計測

Debug ビルド後に以下でカバレッジデータを生成：

```bash
cd build
ctest --coverage
```

このコマンドで以下が生成されます：

- `.gcda` ファイル: 実行時の計測データ
- `.gcno` ファイル: コンパイル時のメタデータ

### 2. gcovr でカバレッジレポートを生成

**HTML レポート（推奨）**:

```bash
cd build
gcovr --root .. \
      --filter='.*target.*' \
      --exclude-lines-by-pattern='.*assert.*' \
      --html-details coverage.html
```

**テキストレポート**:

```bash
gcovr --root .. --filter='.*target.*'
```

**出力例**:

```
GCC Code Coverage Report
Directory: /home/fu-ka/c_test_prj
---------------------------------------------------------
File                                       Lines    Exec  Cover
---------------------------------------------------------
target/jchg/moduleA/moduleA.c              25      25   100.0%
target/jchg/moduleB/moduleB.c              30      30   100.0%
target/jchg/moduleC/moduleC.c              40      40   100.0%
---------------------------------------------------------
TOTAL                                      95      95   100.0%
---------------------------------------------------------
```

**HTML レポートの確認**:

```bash
# ウェブブラウザで開く
open coverage.html
# または
firefox coverage/index.html
```

### 3. lcov でカバレッジレポートを生成

**ステップバイステップ**:

```bash
cd build

# カバレッジ情報を収集
lcov --capture --directory . --output-file coverage.info

# 不要な情報をフィルタリング
lcov --remove coverage.info '/usr/*' '*/GoogleTest/*' '*/fff/*' \
     --output-file coverage_filtered.info

# HTML レポートを生成
genhtml coverage_filtered.info --output-directory html
```

**生成されたファイル**: `build/html/index.html`

### 4. カバレッジレポートの解釈

| メトリック | 説明 | 目標値 |
|----------|------|--------|
| Lines | 実行された行数 | 100% |
| Branches | 分岐が実行されたか | > 90% |
| Functions | 関数が呼ばれたか | 100% |

## パフォーマンス測定

### 1. テスト実行時間の計測

```bash
ctest --output-on-failure -V 2>&1 | grep "Test time"
```

### 2. ビルド時間の計測

```bash
time make
```

**出力例**:

```
real    0m2.341s
user    0m2.120s
sys     0m0.220s
```

### 3. 実行ファイルのサイズ確認

```bash
ls -lh build/tests/module*/test_module*
```

### 4. メモリ使用量の監視

```bash
# Valgrind でメモリリークを検出（インストール必要）
valgrind ./build/tests/moduleC/test_moduleC
```

## CI/CD 統合例

### GitHub Actions での実行

`.github/workflows/build.yml`:

```yaml
name: Build and Test

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake build-essential gcovr
      - name: Configure
        run: |
          mkdir -p build && cd build
          cmake -DCMAKE_BUILD_TYPE=Debug ..
      - name: Build
        run: |
          cd build && make
      - name: Test
        run: |
          cd build && ctest --output-on-failure
      - name: Coverage
        run: |
          cd build
          gcovr --root .. --html-details coverage.html
      - name: Upload coverage
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report
          path: build/coverage.html
```

## トラブルシューティング

### 問題 1: "CMake not found"

**原因**: CMake がインストールされていない

**解決方法**:

```bash
sudo apt-get install cmake
```

### 問題 2: "GoogleTest not found"

**原因**: CMake が GoogleTest を自動ダウンロードできていない

**解決方法**:

```bash
# build ディレクトリを削除してやり直し
cd ..
rm -rf build
mkdir build && cd build
cmake ..
make
```

### 問題 3: テストが失敗する

**デバッグ手順**:

```bash
# 1. 詳細メッセージを表示
cd build
ctest --output-on-failure -V

# 2. テスト実行ファイルを直接実行
./tests/moduleC/test_moduleC --gtest_filter=WriteDataSuccess

# 3. GDB でデバッグ
gdb ./tests/moduleC/test_moduleC
(gdb) run
(gdb) bt    # バックトレース表示
```

### 問題 4: カバレッジレポートが生成されない

**確認項目**:

```bash
# Debug ビルドであるか確認
cmake -DCMAKE_BUILD_TYPE=Debug ..

# .gcda ファイルが生成されているか確認
find build -name "*.gcda" -ls

# gcovr がインストールされているか確認
which gcovr
```

## スクリプトによる自動ビルド

### build.sh の内容

```bash
#!/bin/bash

# ビルドディレクトリの作成
mkdir -p build
cd build

# CMake の設定
cmake -DCMAKE_BUILD_TYPE=Debug ..

# ビルド
make

# テスト実行
ctest --output-on-failure

# カバレッジレポート生成
gcovr --root .. --html-details coverage.html

echo "Build complete! Coverage report: build/coverage.html"
```

### 実行方法

```bash
chmod +x build.sh
./build.sh
```

## ビルド構成の最適化

### 並列ビルド（高速化）

```bash
# 8 個のプロセッサで並列ビルド
make -j8

# または CMake で指定
cmake --build build -j8
```

### ビルドキャッシュの活用

```bash
# 最初のビルド
cd build && cmake .. && make

# 変更後のビルド（キャッシュが効く）
make
```

### インクリメンタルビルド

```bash
# 変更されたファイルのみ再ビルド
make

# 特定のターゲットのみビルド
make test_moduleC
```
