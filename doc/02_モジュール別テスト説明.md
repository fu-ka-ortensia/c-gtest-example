# モジュール別テスト説明

このドキュメントでは、プロジェクトに含まれるサンプルモジュールのテスト構造を説明します。

## テスト構成

プロジェクトには複数のサンプルモジュールが含まれており、それぞれ以下の構成で管理されています。

### ファイル構成

各モジュール（`moduleX`）は以下のような構成を持ちます：

- **実装**: `target/jchg/moduleX/moduleX.c`
- **ヘッダー**: `target/jchg/moduleX/moduleX.h`
- **テスト**: `tests/moduleX/test_moduleX.cpp`

### テストの実行

```bash
# すべてのテストを実行
cd build
ctest --output-on-failure

# 特定のモジュールテストのみ実行
ctest -R "ModuleX" --output-on-failure

# 詳細出力で実行
ctest --output-on-failure -V
```

### テスト実行結果例

```
Test project /path/to/build
    Start 1: ModuleXTest
1/N Test #1: ModuleXTest .....................   Passed    0.00 sec

100% tests passed, 0 tests failed out of N
```

## テスト実装の基本

### GTest テストファイルの構成

テストファイル（`tests/moduleX/test_moduleX.cpp`）は以下の構造を持ちます：

```cpp
#include <gtest/gtest.h>

extern "C" {
    #include "moduleX.h"
}

class ModuleXTest : public ::testing::Test {
    // テスト前後の処理（必要に応じて）
    void SetUp() override { ... }
    void TearDown() override { ... }
};

TEST_F(ModuleXTest, TestName1) {
    // テストロジック
}

TEST_F(ModuleXTest, TestName2) {
    // テストロジック
}
```

### テストケースの作成

1. **テストクラス作成**: `ModuleXTest` という名前で `::testing::Test` を継承
2. **テストメソッド追加**: `TEST_F(ModuleXTest, TestName)` マクロで定義
3. **検証**: `EXPECT_EQ`、`EXPECT_TRUE` などのマクロで検証
4. **実行**: `ctest` コマンドで実行

## CMakeLists.txt 設定

各モジュールのテストは、`tests/moduleX/CMakeLists.txt` で以下のように設定されています：

```cmake
cmake_minimum_required(VERSION 3.10)

set(MODULE_NAME moduleX)

add_executable(test_${MODULE_NAME} test_${MODULE_NAME}.cpp)

target_include_directories(test_${MODULE_NAME} PRIVATE
    ${CMAKE_SOURCE_DIR}/target/jchg/${MODULE_NAME}
    ${CMAKE_SOURCE_DIR}/target/inc
    ${CMAKE_SOURCE_DIR}/fff
)

target_link_libraries(test_${MODULE_NAME}
    gtest
    gtest_main
    pthread
)

target_compile_options(test_${MODULE_NAME} PRIVATE
    -O0 -g --coverage -fprofile-arcs -ftest-coverage
)
target_link_options(test_${MODULE_NAME} PRIVATE
    --coverage -fprofile-arcs -ftest-coverage
)

add_test(NAME ModuleXTest COMMAND test_${MODULE_NAME})
```

### 主要な設定

- **include_directories**: 実装ファイル、共通ヘッダー、FFF ヘッダーへのパス設定
- **link_libraries**: GTest ライブラリのリンク
- **compile_options**: カバレッジ測定オプション

## カバレッジ測定

### 実行とレポート生成

```bash
cd build && make && ctest
lcov --directory . --capture --output-file coverage.info
genhtml coverage.info --output-directory html
```

### カバレッジレポート確認

```bash
open html/index.html  # macOS
xdg-open html/index.html  # Linux
```

### レポート内容

- 行カバレッジ: 実行された行数の割合
- 関数カバレッジ: 実行された関数の割合
- ブランチカバレッジ: 実行された分岐の割合

## よくあるテストパターン

### パターン 1: 基本的な機能テスト

```cpp
TEST_F(ModuleXTest, BasicFunctionality) {
    // 入力を設定
    // 関数を呼び出し
    // 結果を検証
    EXPECT_EQ(expected, actual);
}
```

### パターン 2: エラーハンドリング

```cpp
TEST_F(ModuleXTest, ErrorHandling) {
    // 不正な入力
    s4 result = moduleX_function(invalid_input);
    // エラーコードの検証
    EXPECT_EQ(ERROR_CODE, result);
}
```

### パターン 3: 外部依存関数のスタブ化（FFF）

```cpp
extern "C" {
    #include "moduleX.h"
    #define DEFINE_FFF_GLOBALS
    #include "fff.h"
    FAKE_VALUE_FUNC2(u4, external_function, u1*, u4);
}

TEST_F(ModuleXTest, WithStub) {
    RESET_FAKE(external_function);
    external_function_fake.return_val = 100;
    
    // テスト実行
    s4 result = moduleX_function_using_external();
    
    // スタブの呼び出し検証
    EXPECT_EQ(1, external_function_fake.call_count);
    EXPECT_EQ(100, result);
}
```

## トラブルシューティング

### テストがビルドできない場合

1. `tests/CMakeLists.txt` で `add_subdirectory(moduleX)` が追加されているか確認
2. 実装ファイルのパスが正しいか確認
3. インクルードパスが正しいか確認

### テストが実行されない場合

```bash
cd build
ctest --verbose
```

で詳細を確認してください。

### カバレッジが計測されない場合

- `--coverage` フラグがコンパイルオプションに含まれているか確認
- `-fprofile-arcs -ftest-coverage` フラグが設定されているか確認
- ビルドを再実行してください

## 参照

- [00_プロジェクト概要](00_プロジェクト概要.md)
- [01_環境構築ガイド](01_環境構築ガイド.md)
- [03_FFFスタブ化ガイド](03_FFFスタブ化ガイド.md)
- [04_ビルドと実行ガイド](04_ビルドと実行ガイド.md)

### テスト対象ファイル

- **実装**: `target/jchg/moduleA/moduleA.c`
- **ヘッダー**: `target/jchg/moduleA/moduleA.h`
- **テスト**: `tests/moduleA/test_moduleA.cpp`

### 実行方法

```bash
cd build/tests/moduleA
./test_moduleA
```

## moduleB テスト

### テスト対象ファイル

- **実装**: `target/jchg/moduleB/moduleB.c`
- **ヘッダー**: `target/jchg/moduleB/moduleB.h`
- **テスト**: `tests/moduleB/test_moduleB.cpp`

### 実行方法

```bash
cd build/tests/moduleB
./test_moduleB
```

## 統合テスト実行

すべてのテストを一括実行：

```bash
cd build
ctest --output-on-failure
```

### 実行結果の表示

```bash
# 詳細表示
ctest --output-on-failure -V

# テスト結果を XML で出力
ctest -T Test --output-xml test-results.xml

# カバレッジレポート生成
ctest --coverage
```

## テストの特徴

### GTest フレームワーク

- **TEST マクロ**: テストケースの定義
  ```cpp
  TEST(テストスイート名, テストケース名) {
      // テスト実装
  }
  ```

- **EXPECT_EQ**: 値の等価性チェック
  ```cpp
  EXPECT_EQ(期待値, 実際の値);
  ```

- **ASSERT_**: テスト失敗時に即座に中断
  ```cpp
  ASSERT_EQ(期待値, 実際の値);
  ```

### FFF スタブ化

#### 基本的な使い方

```cpp
// 1. FFF グローバル変数を定義
DEFINE_FFF_GLOBALS;

// 2. スタブ関数を宣言（引数が 2 個の場合）
FAKE_VALUE_FUNC2(u4, u4g_mem_wirte, u1*, u4);

// 3. テスト内で使用
TEST(ModuleCTest, WriteDataSuccess) {
    // テスト前にリセット
    RESET_FAKE(u4g_mem_wirte);
    
    // 戻り値を設定
    u4g_mem_wirte_fake.return_val = 4;
    
    // 関数を呼び出し
    u4 result = moduleC_write_data(test_data, 4);
    
    // 検証
    EXPECT_EQ(4, result);
    EXPECT_EQ(1, u4g_mem_wirte_fake.call_count);
}
```

#### FFF マクロリファレンス

| マクロ | 説明 |
|--------|------|
| `DEFINE_FFF_GLOBALS` | グローバルスタブ変数を定義 |
| `FAKE_VALUE_FUNC0-20` | N 個の引数を持つスタブを宣言 |
| `RESET_FAKE(func)` | スタブをリセット |
| `func_fake.return_val` | 戻り値を設定 |
| `func_fake.arg0_val` | 第 1 引数の値を取得 |
| `func_fake.arg1_val` | 第 2 引数の値を取得 |
| `func_fake.call_count` | 呼び出し回数を取得 |

## テスト結果ファイル

ビルドディレクトリ内に以下が生成されます：

- `tests/moduleC/CMakeFiles/test_moduleC.dir/test_moduleC.cpp.gcda`: カバレッジデータ
- `tests/moduleC/CMakeFiles/test_moduleC.dir/test_moduleC.cpp.gcno`: カバレッジメタデータ

### カバレッジレポート生成

```bash
# gcovr を使用したカバレッジレポート
cd build
gcovr --root .. --html-details coverage.html

# または lcov を使用
lcov --capture --directory . --output-file coverage.info
genhtml coverage.info --output-directory html
```
